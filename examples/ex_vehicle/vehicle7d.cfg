#-----------------------------------------------------------------------
# File: vehicle7d.cfg
#-----------------------------------------------------------------------

# Brief description: This code is written for the "networks of discrete-time stochastic control/switched systems" meeting the following two purposes: 
# In the first part of the code, we build finite MDPs as finite abstractions of the given systems. In the second part, we synthesize controllers for the constructed finite MDPs satisfying some high-level specifications. 
# The stochasticity inside the model should be additive noise.
# This code is able to build finite MDPs for the "general setting" of discrete-time nonlinear stochastic control/switched systems, but synthesize controllers for some class of specifications (safety and reachability).
# This code also accepts the effects of other subsystems as disturbances with bounded intervals. If one is interested in working on the interconnected system (without disturbances), the disturbance should be implemented as zero.
# This configuration file utilizes the kernel GB_FP to build a finite MDP together with synthesize a controller for a road traffic network.

#-----------------------------------------------------------------------
# Project Data
#-----------------------------------------------------------------------
# (Project name) is essential. It will be used for names of output files.
project_name = "vehicle7d";

#-----------------------------------------------------------------------
# Output Memory Model
#-----------------------------------------------------------------------
# The (data) tells the tool which memory model should be used when saving results
# use the values : raw | bits | bitmap | bdd
data = "raw";
save_transitions = "false";
save_controller = "true";

#-----------------------------------------------------------------------
# State/Input/Disturbance Sets
#-----------------------------------------------------------------------
# The user is asked to provide the range of the state, input and disturbance intervals.
# The lower and upper bounds of the sets are respectively indicated by "lb" and "ub". The disceretization parameters are also designated by "eta".

states{
	dim = "7";
	eta = " 1.0,  1.0,  0.20,  1.0,  0.1,  0.2,  0.02";
	lb  = "-1.5, -1.5, -0.40, -2.0, -0.3, -0.4, -0.04";
	ub  = " 1.5,  1.5,  0.40,  2.0,  0.3,  0.4,  0.04";
}

inputs{
	dim = "2";
	eta = " 0.2,  2.0";
	lb  = "-0.4, -4.0";
	ub  = " 0.4,  4.0";
}

#-----------------------------------------------------------------------
# System-Post Dynamics
#-----------------------------------------------------------------------
# The user is required to provide the desired dynamics.
# The additive noise inside the dynamics is not needed to be implemented. Instead, the covariance matrix of the noises will be later asked to be implemented.
# Your post variables should start with (xx) followed by the index of the dimension (starting from 0 not 1).
# Maximum number of dimensions is (states.dim)
# you are allowed to use:
#  - array indexing to access states in x (e.g., x0 as the first state variable)
#  - array indexing to access inputs in u (e.g., u0 as the first input variable)
#  - array indexing to access disturbances in u (e.g., w0 as the first distrubance variable)
#  - any math function from: https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/mathFunctions.html
post_dynamics{
	constant_values = "float Ts=0.1f, lwb = 2.57891f, mu = 1.0489f, C_Sf = 20.89808f, C_Sr = 20.89808f, lf = 1.1561957f, lr = 1.422717f, h = 0.61373f, m = 1093.29f, I = 1791.59f, g = 9.81f;";

	xx0 = "0";
    xx1 = "0";
    xx2 = "0";
	xx3 = "0";
	xx4 = "0";
	xx5 = "0";
	xx6 = "0";

    code_after = "if (fabs(x3) < 0.1) { xx[0] = x3*cos(x4); xx[1] = x3*sin(x4); xx[2] = u0; xx[3] = u1; xx[4] = x3/lwb*tan(x2); xx[5] = u1*lwb*tan(x2) + x3/(lwb*cos(x2)*cos(x2))*u0; xx[6] = 0; }else{ xx[0] = x3*cos(x6 + x4); xx[1] = x3*sin(x6 + x4); xx[2] = u0; xx[3] = u1; xx[4] = x5; xx[5] = -mu*m/(x3*I*(lr+lf))*(lf*lf*C_Sf*(g*lr-u1*h) + lr*lr*C_Sr*(g*lf + u1*h))*x5+mu*m/(I*(lr+lf))*(lr*C_Sr*(g*lf + u1*h) - lf*C_Sf*(g*lr - u1*h))*x6+mu*m/(I*(lr+lf))*lf*C_Sf*(g*lr - u1*h)*x2; xx[6] = (mu/(x3*x3*(lr+lf))*(C_Sr*(g*lf + u1*h)*lr - C_Sf*(g*lr - u1*h)*lf)-1)*x5-mu/(x3*(lr+lf))*(C_Sr*(g*lf + u1*h) + C_Sf*(g*lr-u1*h))*x6+mu/(x3*(lr+lf))*(C_Sf*(g*lr-u1*h))*x2;}";
}

#-----------------------------------------------------------------------
# Information of the Noises
#-----------------------------------------------------------------------
# The user is also asked to provide the inverse and the determinant of the covariance matrix of the noises. 
# The original covariance matrix should be positive semi-definite.
# The cutting probability should be a value below th max value of the PDF and used to cut the probability below
# it and cosider any values below it as zero.
noise{
	inv_covariance_matrix = "4.0,4.0,0.5,10.0,0.5,0.5,0.5";
	det_covariance_matrix = "0.1";
    cutting_probability = "1e-5";
#	cutting_probability = "0";
    cutting_region = "{{-0.5,0.5},{-0.5,0.5},{-0.4, 0.4},{-2.0,2.0},{-0.1,0.1},{-0.2,0.2},{-0.02,0.02}}";
}

#-----------------------------------------------------------------------
# Specifications
#-----------------------------------------------------------------------
# This code is able to synthesize controllers for the "safety and reachability" pecifications.
# type = safe | reach
# If the property of interest is "safety", the user is asked to provide the range of the safe set.

specs {
	type = "reach";
	hyperrect = "{{-1.75,0.25},{-0.25,1.75},{-0.45, 0.45},{-4.5,4.5},{-0.35,0.35},{-0.45,0.45},{-0.045,0.045}}";
    avoid_hyperrect = "{{-1.75,0.25},{-0.75,-0.25},{-0.45, 0.45},{-4.5,4.5},{-0.35,0.35},{-0.45,0.45},{-0.045,0.045}}";
	time_steps = "16";
}